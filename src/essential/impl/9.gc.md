# 垃圾回收

垃圾回收要干的事就是将不再使用的对象内存释放，腾出空间给其它对象使用。就这么简单的一句描述但它实现起来却非常不简单，垃圾回收的发展历史已经有了几十年，最早在上世纪60年代的Lisp语言就首次采用了垃圾回收机制，我们所熟知的Python，Objective-C，其主要的GC机制就是引用计数，Java，C#采用的是分代回收。早期Go的垃圾回收机制十分的简陋，只有简单的标记清除算法，垃圾回收所造成的STW（Stop The World，指因垃圾回收暂停整个程序）高达几百毫秒甚至几秒可能更久，现如今经过了数十年的发展，GC平均延时已经改进到了微秒级别，即便是最坏情况下也只有几毫秒。

在今天来看垃圾回收，从回收算法来看，可以大致分为下面几个大类：

- 标记清除：将活动的对象做标记，将未标记的对象进行回收
- 引用计数：让每一个对象记录自身被引用了多少次，当计数为0时，就将其回收
- 复制算法：将活动对象复制到新的内存中，将旧内存中的所有对象全部回收，达到回收垃圾目的
- 标记压缩：标记清除的升级版，回收时将活动对象移动到堆的头部，方便管理

从应用方式来看，可以分为下面几个大类：

- 全局回收：一次直接回收所有的垃圾
- 分代回收：根据对象的存活时间分成不同的代，然后采用不同的回收算法
- 增量回收：每一次只进行局部的垃圾回收

Go现如今采用的垃圾回收机制就是升级版的标记清除算法+增量并发回收，也就是本文要讲解的内容。



## 标记

现如今Go的GC算法依然是先标记后清除这样一个步骤，但其实现不再像以前一样简单。



### 标记-清除

先从最简单的标记清除算法开始讲起，在内存中，对象与对象之间的引用关系会构成一个图，垃圾回收的工作就在这个图上进行，工作分为两个阶段：

- 标记阶段：从根节点（根节点通常是栈上的变量，全局变量等活跃对象）开始，逐个遍历每一个可以到达的节点，并将其标记为活跃对象，直到遍历完所有可以到达的节点，
- 清除阶段：遍历堆中的所有对象，将未标记的对象回收，将其内存空间释放或是复用。

<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202406051711875.png" style="zoom:67%;" />

在回收的过程中，对象图的结构不能被改变，所以要将整个程序停止，也就是STW，回收完毕以后才能继续运行，这种算法的缺点就在于耗时较长，比较影响程序的运行效率，这是早期版本Go使用的标记算法，它的缺点比较明显

- 会产生内存碎片（由于Go TCMalloc式的内存管理方式，碎片问题的影响并不大）
- 在标记阶段会扫描堆的所有对象
- 会导致STW，暂停整个程序，且时间不短



### 三色标记

为了改进效率，Go采用了经典的三色标记算法，所谓三色，指的是黑灰白三色：

- 黑色：在标记过程中对象已访问过，并且它所直接引用的对象也都已经访问过，表示活跃的对象
- 灰色：在标记过程中对象已访问过，但它所直接引用的对象并未全部访问，当全部访问完后会转变为黑色，表示活跃的对象
- 白色：在标记过程中从未被访问过，在访问过后会变为灰色，表示可能为垃圾对象，

在三色标记工作开始时，场上只有灰色和白色对象，所有根对象都是灰色，其它对象都是白色，如下图所示

![](https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202406051641610.png)

每一轮标记开始时，先从灰色对象开始，将灰色对象标记为黑色，表示其为活跃对象，然后再将黑色对象所有直接引用的对象标记为灰色，剩下的就是白色，此时场上就有了黑白灰三种颜色。

![](https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202406051650287.png)

不断重复上述步骤，直到场上只剩下黑色和白色对象，当灰色对象集合为空时，就代表着标记结束，如下图

![](https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202406051703833.png)

在标记结束后，在清除阶段只需将白色集合中对象的内存释放即可。



### 不变性

三色标记法本身没法进行并发标记（指程序一边运行一边标记），如果在标记时对象图结构发生了改变，这可能会导致两种情况

- 多标：在对象被标记为黑色对象后，用户程序删除了对于该对象的所有引用，那么它应该是白色对象需要被清除
- 漏标：在对象被标记为白色对象后，用户程序中有其它对象引用了该对象，那么它应该是黑色对象不应该被清除

对于第一种情况其实可以接受，因为未被清理的对象可以在下一轮回收中被处理掉。但第二种情况就没法接受了，正在使用中的对象内存被错误的释放，会造成严重的程序错误，这是必须要避免的问题。

三色不变性这一概念来自于Pekka P. Pirinen于1998年发表的论文[《Barrier techniques for incremental tracing》](https://dl.acm.org/doi/epdf/10.1145/301589.286863)，它指在并发标记时的对象颜色的两个不变性：

- 强三色不变性：黑色对象不可以直接引用白色对象

- 弱三色不变性：当黑色对象直接引用白色对象时，必须有另一个灰色对象可以直接或间接访问到该灰色对象，称作受到灰色对象的保护

对于强三色不变性而言，已知黑色对象3是已经访问过的对象，且其子对象也全都访问过并标记为灰色对象，如果此时用户程序并发的给黑色对象3添加白色对象7的新引用，正常来说白色对象7应该被标记为灰色，但由于黑色对象3已经被访问过了，对象7不会被访问，所以它始终都是白色对象，并最终被错误的清理掉。

![](https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202406052226227.png)

对于弱三色不变性而言，它其实跟强三色不变性同理，因为灰色对象能够直接或间接的访问到该白色对象，后续标记过程中它最终会被标记为灰色对象，从而避免被误清理。

<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202406052237769.png" style="zoom:50%;" />



通过不变性，可以确保在标记过程中不会有对象被误清理，也就能保证并发条件下的标记工作的正确性，从而可以使得三色标记并发的工作，这样一来其标记效率相比于标记-清除算法会提升相当多。要保证三色不变性，其关键就在于屏障技术。



## 屏障

内存屏障的作用可以理解为hook了对象的赋值行为，在赋值前做一些指定的操作，这种hook代码通常在编译期间由编译器插入到代码中。前面提到过，三色标记在并发情况下添加和删除对象引用都会导致问题，由于这两个都是写操作（删除就是赋空值），所以拦截它们的屏障被统称为写屏障。但屏障机制并非毫无成本，拦截内存写操作会造成额外的开销，因此屏障机制只在堆上生效，考虑到实现复杂度和性能损耗，对于栈和寄存器则不起作用范围内。

::: tip

想要了解更多Go对于屏障技术的应用细节，前往[Eliminate STW stack rescan](https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md)阅读英文原文，本文参考了许多内容。

:::



### 插入写屏障

插入写屏障由Dijkstra提出的，它满足强三色不变式。当给黑色对象添加了一个新的白色对象引用时，插入写屏障会拦截此操作，将该白色对象标记为灰色，这样可以避免黑色对象直接引用白色对象，保证了强三色不变性，这个相当好理解。

![](https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202406052336189.png)

前面提到过写屏障不会应用在栈上，如果在并发标记的过程中栈对象的引用关系发生了变化，比如栈中的黑色对象引用了堆中的白色对象，所以为了确保栈对象的正确性，只能在标记结束后再次将栈中的所有对象全部标记为灰色对象，然后重新扫描一遍，等于是一轮标记要扫描两次栈空间，并且第二次扫描时必须要STW，假如程序中同时存在成百上千个协程栈，那么这一扫描过程的耗时将不容忽视，根据官方统计的数据，重新扫描的耗时大概在10-100毫秒左右。

优点：扫描时不需要STW

缺点：需要二次扫描栈空间保证正确性，需要STW



### 删除写屏障

删除写屏障由Yuasa提出，又称基于起始快照的屏障，该方式在开始时需要STW来对根对象进行快照记录，并且它会将所有根对象标黑，所有的一级子对象标灰，这样其余的白色子对象都会处于灰色对象的保护之下。Go团队并没有直接应用删除写屏障，而是选择了将其与插入写屏障混合使用，所以为了方便后续的理解，这里还是要讲一下。删除写屏障在并发条件下保证正确性的规则是：当从灰色或白色对象删除对白色对象的引用时，都会直接将白色对象标记为灰色对象。

分两种情况来解读：

- 删除灰色对象对于白色对象的引用：由于不知道白色对象下游是否被黑色对象引用，此举可能会切断灰色对象对于白色对象的保护

- 删除白色对象对于白色对象的引用：由于不知道白色对象上游是否被灰色保护，下游是否被黑色对象引用，此举也可能会切断灰色对于白色对象的保护

不管是哪种情况，删除写屏障都会将被引用的白色对象标记为灰色，这样一来就能满足弱三色不变式。这是一种保守的做法，因为上下游情况未知，将其标记为灰色就等于不再视其为垃圾对象，就算删除引用后会导致该对象不可达也就是成为垃圾对象时，也仍然会将其标记为灰色，它会在下轮扫描中被释放掉，这总好过对象被误清理而导致的内存错误。

![](https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202406061744903.png)

优点：由于栈对象全黑，所以不需要二次扫描栈空间

缺点：在扫描开始时需要STW来对栈空间的根对象进行快照



### 混合写屏障

go1.8版本引用了新的屏障机制：混合写屏障，即插入写屏障与删除写屏障的混合，结合了它们两个的优点：

- 插入写屏障起始时不需要STW来进行快照
- 删除写屏障不需要STW来二次扫描栈空间

下面是官方给出的的伪代码：

```
writePointer(slot, ptr):
    shade(*slot)
    if current stack is grey:
        shade(ptr)
    *slot = ptr
```
简单讲解下里面的一些概念，其中`slot`是一个指针，表示对其它对象的引用，`*slot`是原对象，`ptr`是新对象，`*slot=ptr`是一次赋值操作，等于修改对象的引用，赋空值就是删除引用，`shade()`表示将一个对象标记为灰色，`shade(*slot)`就是将原对象标记为灰色，`shade(ptr)`就是将新对象标记为灰色，下面是一个例图，假设对象1原来引用着对象2，然后用户程序修改了引用，让对象1引用了对象3，混合写屏障捕捉到了这一行为，其中`*slot`代表的就是对象2，`ptr`代表的就是对象1。

![](https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202406062107110.png)

官方用一句话概括了上面伪代码的作用

> the write barrier shades the object whose reference is being overwritten, and, if the current goroutine's stack has not yet been scanned, also shades the reference being installed.

翻译过来就是，当混合写屏障拦截到写操作时，会将原对象标记为灰色，如果当前协程栈还未被扫描过时，就将新对象也标记为灰色。

标记工作开始时，需要扫描栈空间以收集根对象，这时会直接将其全部标记为黑色，并且任何在栈中创建的新对象也会被标记为黑色，保证栈中的所有都是黑色对象，所以伪代码中的`current stack is grey`表示的就是当前协程栈还未被扫描过，所以协程栈只有两种状态，要么全黑要么全灰，在由全灰变为全黑的过程中是需要暂停当前协程的，所以在混合写屏障下依然会有局部的STW。当协程栈全黑时，此时一定满足强三色不变式，因为扫描后栈中的黑色对象只会引用灰色对象，不会存在黑色对象直接引用白色对象的情况，所以此时不需要插入写屏障，对应伪代码

```
if current stack is grey:
        shade(ptr)
```

但仍然需要删除写屏障来使堆满足弱三色不变式，也就是

```
shade(*slot)
```

<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202406062218312.png" style="zoom:50%;" />

在扫描完毕后，由于栈空间的对象已经是全黑的了，就不再需要去二次扫描栈空间了，可以节省掉STW的时间。

至此，也就是go1.8版本往后，Go大体上确立了垃圾回收的基本框架，后续版本有关垃圾回收的优化也都是建立在混合写屏障的基础之上的，由于已经消除了大部分的STW，此时垃圾回收的平均延时已经降低到了微秒级别。大部分情况下低于100微秒，GC性能已经满足了绝大多数的业务场景。





### 着色缓存

在之前提到的屏障机制中，在拦截到写操作时都是立即标记对象颜色，在采用混合写屏障后，由于需要对原对象和新对象都行进行标记。所以工作量会翻倍，同时编译器插入的代码也会增加。为了进行优化，在go1.11版本中，写屏障在进行着色时不再会立即标记对象颜色，而是会将原对象和新对象存入一个缓存池中，等积攒到了一定数量后，再进行批量标记，这样做会比以前效率更高。



## 回收
