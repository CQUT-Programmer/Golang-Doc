# 分支

如果说有什么特性能让git从其它vcs中脱颖而出，那唯一的答案就是git的分支管理。在git中每一次提交都会包含一个指针，它指向的是该次提交的内容快照，同时也会指向上一次提交。

![](https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309081917035.png)

git的分支，实际上是指向提交对象的可变指针，如图所示。通过如下命令可以看到分支所指向提交的情况

```sh
$ git log --oneline --decorate
f5602b9 (HEAD -> main, tag: v1.0.3, tag: v1.0.1, tag: v1.0.0, origin/main) Revert "revert example"
9d3a0a3 revert example
25cdeea a
10e5e5e commit
c7bdcd8 update aaa.txt
e538986 skip stage
b4c2d7f 3rd commit
5ca7961 hello
eff484a initial commit
```

## 创建切换

从图中和输出中我们可以看到，HEAD此时是指向main分支，于此同时，main分支与test分支都是指向的`f5602b9`这一提交，并且还有很多tag，除此之外，还可以看到`origin/main`这一远程分支。接下来创建一个新的分支试试，通过如下命令可以创建一个分支

```sh
$ git branch test
```

创建完成后，使用`git checkout <branchname>`来切换到指定分支

```sh
$ git switch test
```

如果想要创建的同时并切换切换成该分支可以使用`-b`参数，例如

```sh
$ git switch -c test
```

命令`git checkout <branchname>`也可以切换分支，使用`git checkout -b <branchname>`也能达到创建并切换的效果，事实上`git switch`使用的还是`git checkout`。

::: tip

`git switch`命令相对`git checkout`命令比较新，同时也可能不那么稳定。

:::

![](https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309081917091.png)

分支切换后，HEAD指针就会指向test分支，HEAD指针永远指向当前所在的分支，通过它就可以知道现在仓库的状态处于哪一个分支。接下来做一个提交来看看。

```sh
$ echo "branch test update it" >> hello.txt

$ git commit -a -m "update hello.txt on test branch"
[test 9105078] update hello.txt on test branch
 1 file changed, 1 insertion(+)
 
$ git log --oneline --decorate
9105078 (HEAD -> test) update hello.txt on test branch
f5602b9 (tag: v1.0.3, tag: v1.0.1, tag: v1.0.0, origin/main, main) Revert "revert example"
9d3a0a3 revert example
25cdeea a
10e5e5e commit
c7bdcd8 update aaa.txt
e538986 skip stage
b4c2d7f 3rd commit
5ca7961 hello
eff484a initial commit

```

![](https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309081909312.png)

可以从输出中看到，test分支此时指向的是`9105078`这个提交，而main分支依旧是指向的原来的那个提交。当分支切换回去时，会发现HEAD再次指向了main分支。

```sh
$ git switch main
Switched to branch 'main'
Your branch is up to date with 'origin/main'.

$ git log --oneline --decorate
f5602b9 (HEAD -> main, tag: v1.0.3, tag: v1.0.1, tag: v1.0.0, origin/main) Revert "revert example"
9d3a0a3 revert example
25cdeea a
10e5e5e commit
c7bdcd8 update aaa.txt
e538986 skip stage
b4c2d7f 3rd commit
5ca7961 hello
eff484a initial commit

```

这时再做出一些修改并提交，可以看到HEAD和main分支都指向了最新的提交。

```sh
$ echo "update on branch main" >> hello.txt
Stranger@LAPTOP-9VDMJGFL MINGW64 /d/WorkSpace/Code/example (main)
$ git commit -a -m "update on main"
[main d0872e5] update on main
 1 file changed, 1 insertion(+)
$ git log --oneline --decorate
d0872e5 (HEAD -> main) update on main
f5602b9 (tag: v1.0.3, tag: v1.0.1, tag: v1.0.0, origin/main) Revert "revert example"
9d3a0a3 revert example
25cdeea a
10e5e5e commit
c7bdcd8 update aaa.txt
e538986 skip stage
b4c2d7f 3rd commit
5ca7961 hello
```

再来查看提交日志，git很形象的表示了所有分支的状态。

```sh
$ git log --oneline --decorate --graph --all
* d0872e5 (HEAD -> main) update on main
| * 9105078 (test) update hello.txt on test branch
|/
* f5602b9 (tag: v1.0.3, tag: v1.0.1, tag: v1.0.0, origin/main) Revert "revert example"
* 9d3a0a3 revert example
* 25cdeea a
* 10e5e5e commit
* c7bdcd8 update aaa.txt
* e538986 skip stage
* b4c2d7f 3rd commit
* 5ca7961 hello
* eff484a initial commit
```

![](https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309081910241.png)

git的输出就如图所示，main与test两个分支最初都指向的同一个提交，在随着有了新的提交后，它们都分别指向了各自不同的提交，当想要切换分支时，git就会将HEAD指针指向指定的分支，并将工作区恢复成该分支所指向提交的状态，在git中，分支的切换仅仅只是指针的移动，所以切换起来相当的迅速。正应如此，开发人员可以随心所欲的创建属于自己的分支来给仓库添加新的特性，这些变更在最后合并分支时都出现在主分支中。

::: tip

刚刚提到的主分支，只是对开发人员的一个概念，git中没有什么特殊分支，起名为main仅仅只是将它看待成主分支，实际上它与test分支并没有什么不同，默认的master分支也只是git的一个默认名称而已。

:::



## 临时修改

在分支切换时，git会将工作区切换到该分支所指向提交的状态，并且暂存区会被清空，这就意味着，如果在切换分支时有未提交的修改，那么这些修改将会丢失。不过git显然不允许这样的情况发生，它会这样提示你。

```sh
$ git switch test
error: Your local changes to the following files would be overwritten by checkout:
        hello.txt
Please commit your changes or stash them before you switch branches.
Aborting
```

::: warning

如果你非要这么做，可以加上`--discard-changes`参数来丢弃修改或者`--merge`合并修改。

:::

在进行危险操作时git总会提醒你不要这么做，从输出中可以得知，当本地有未提交的修改时，git不允许切换分支，要么把修改提交了，要么就使用一个名为`git stash`。它可以将本地未提交的修改临时保存起来，待将分支切换回来以后，还可以将这些修改复原，回到之前的状态，以便继续这个分支的开发工作。示例如下

```sh
$ echo "123" >> hello.txt
$ git add hello.txt
$ git switch test
error: Your local changes to the following files would be overwritten by checkout:
        hello.txt
Please commit your changes or stash them before you switch branches.
Aborting
$ git stash
Saved working directory and index state WIP on main: d0872e5 update on main
$ git switch test
Switched to branch 'test'
```

这里先做了一些修改，将修改添加到了暂存区但未提交，只要是被追踪的文件发生变化，这里不添加到暂存区一样会被阻止，如果不添加到暂存区，git在stash时会自动添加将修改添加到暂存区。可以看到在切换分支时被git阻止了，于是使用`git stash`命令将这些修改临时存放后成功切换到了test分支。然后再切换回来，使用`git stash pop`来恢复最近一个临时保存的修改。

```sh
$ git switch main
Switched to branch 'main'
Your branch is ahead of 'origin/main' by 1 commit.
  (use "git push" to publish your local commits)

$ git stash pop
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   hello.txt

no changes added to commit (use "git add" and/or "git commit -a")
Dropped refs/stash@{0} (f4a0c807addcd08959555e02d4191fb5324dad88)
```

可以看到仓库状态又变成了未暂存的修改，一旦临时修改被恢复过后，它就会被移出，正如pop所表达的含义一样。我们可以进行多次临时保存，并选择特定的修改来恢复。这里分别进行两次修改，然后临时保存两次。

```sh
$ echo "123" >> hello.txt
$ git stash
Saved working directory and index state WIP on test: 0224b74 initial commit
$ echo "12345" >> hello.txt
$ git stash
Saved working directory and index state WIP on test: 0224b74 initial commit
$ git stash show
 hello.txt | 1 +
 1 file changed, 1 insertion(+)
$ git stash list
stash@{0}: WIP on test: 0224b74 initial commit
stash@{1}: WIP on test: 0224b74 initial commit
```

通过输出可以发现有两个临时保存的修改，存放的顺序就跟栈一样，后进先出，最上面的就是最新的修改。这时可以使用命令`git stash apply`来恢复指定的修改。

```sh
$ git stash apply stash@P{index}
```

如果恢复完成过后，想要删除的话，使用如下命令

```sh
$ git stash drop stash@P{index}
```

`git stash pop`就是将最近的一次修改恢复并删除。也可以使用`clear`命令来一次性删除所有的修改

```sh
$ git stash clear
```

在上面的输出中可以看到，`stash`输出的修改列表除了索引不一样，其它都没什么区别，这样很难区分到底做了什么修改。为此，可以加上`-m`参数。

```sh
$ echo "456" >> hello.txt
$ git stash push -m "456"
Saved working directory and index state On test: 456
$ git stash list
stash@{0}: On test: 456
$ echo "789" >> hello.txt
$ git stash -m "789"
Saved working directory and index state On test: 789
$ git stash list
stash@{0}: On test: 789
stash@{1}: On test: 456
```

从输出中可以看到，当`git stash`不带子命令直接执行时，其实就是执行的`git stash push`，加上`-m`参数以后，查看修改历史就可以看到我们自定义的信息了。